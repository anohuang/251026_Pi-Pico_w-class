# LED 按鈕切換程式說明

## 程式功能概述

本程式實現了一個按鈕控制的 LED 切換功能，當按下按鈕並放開後，會切換 LED 的狀態（紅燈與黃燈交替）。程式內建防彈跳（Debouncing）機制，確保按鈕操作的穩定性。

## 硬體配置

- **按鈕接腳**：GPIO 14（使用內部上拉電阻）
- **紅燈 LED**：GPIO 15
- **黃燈 LED**：GPIO 13

## 變數說明

### 硬體初始化變數
- `btn_pin = 14`：按鈕連接的 GPIO 接腳編號
- `rled_pin = 15`：紅燈 LED 連接的 GPIO 接腳編號
- `yled_pin = 13`：黃燈 LED 連接的 GPIO 接腳編號

### 狀態追蹤變數
- `led_state`：布林值，追蹤當前 LED 狀態
  - `True`：紅燈亮、黃燈滅
  - `False`：紅燈滅、黃燈亮
- `last_button_state`：記錄按鈕的前一個狀態，用於檢測狀態變化

### 防彈跳參數
- `DEBOUNCE_DELAY = 50`：防彈跳延遲時間（毫秒）

## 程式邏輯流程

### 1. 初始化階段

```python
# 設定按鈕為輸入模式，啟用內部上拉電阻
button = Pin(btn_pin, Pin.IN, Pin.PULL_UP)

# 設定 LED 為輸出模式
rled = Pin(rled_pin, Pin.OUT)
yled = Pin(yled_pin, Pin.OUT)

# 設定初始狀態：紅燈亮、黃燈滅
led_state = True
rled.on()
yled.off()

# 記錄按鈕初始狀態
last_button_state = button.value()  # 應該是 1（未按下）
```

**說明**：
- 使用 `Pin.PULL_UP` 表示按鈕未按下時讀取值為 `1`（高電位）
- 按下按鈕時，讀取值為 `0`（低電位）
- 初始狀態設定為紅燈亮

### 2. 主迴圈邏輯

主迴圈持續監控按鈕狀態，並在檢測到「按下→放開」的完整動作後切換 LED 狀態。

#### 步驟 1：讀取當前按鈕狀態
```python
current_button_state = button.value()
```
- 讀取按鈕當前的電位狀態

#### 步驟 2：檢測按下邊緣（Edge Detection）
```python
if last_button_state == 1 and current_button_state == 0:
```
- **邊緣檢測**：只處理從「未按下（1）」到「按下（0）」的狀態轉換
- 這確保每次按鈕操作只觸發一次切換，而不是在按鈕持續按下時重複觸發

#### 步驟 3：第一次防彈跳處理（按下時）
```python
sleep(DEBOUNCE_DELAY / 1000)  # 等待 50ms
if button.value() == 0:  # 確認按鈕確實被按下
```
- 等待 50ms 讓按鈕的物理彈跳穩定下來
- 再次檢查按鈕狀態，確認確實被按下（值仍為 0）
- 如果狀態改變，表示可能是彈跳造成的誤觸發，不執行後續動作

#### 步驟 4：等待按鈕放開
```python
while button.value() == 0:
    sleep(0.01)  # 短暫延遲，避免過度占用 CPU
```
- 持續監控按鈕狀態，直到按鈕被放開（值變為 1）
- 使用短暫延遲避免 CPU 過度占用

#### 步驟 5：第二次防彈跳處理（放開時）
```python
sleep(DEBOUNCE_DELAY / 1000)  # 等待 50ms
if button.value() == 1:  # 確認按鈕確實已放開
```
- 等待 50ms 讓按鈕放開時的物理彈跳穩定下來
- 再次檢查按鈕狀態，確認確實已放開（值為 1）

#### 步驟 6：切換 LED 狀態
```python
led_state = not led_state  # 切換狀態
if led_state:
    rled.on()
    yled.off()
else:
    rled.off()
    yled.on()
```
- 切換 `led_state` 的值
- 根據新狀態更新 LED 的亮滅

#### 步驟 7：更新狀態記錄
```python
last_button_state = current_button_state
sleep(0.01)  # 短暫延遲
```
- 更新按鈕前一個狀態，供下次迴圈使用
- 短暫延遲避免 CPU 過度占用

## 防彈跳機制詳解

### 什麼是彈跳（Bouncing）？

當機械按鈕被按下或放開時，由於機械接觸的物理特性，在穩定接觸前會產生多次快速開關的現象，這稱為「彈跳」。彈跳會導致微控制器讀取到多次狀態變化，造成誤觸發。

### 本程式的防彈跳策略

採用**雙重防彈跳檢查**：

1. **按下時的防彈跳**：
   - 檢測到按下邊緣後，等待 50ms
   - 再次確認按鈕確實被按下
   - 如果狀態改變，表示可能是彈跳，不執行動作

2. **放開時的防彈跳**：
   - 檢測到放開後，等待 50ms
   - 再次確認按鈕確實已放開
   - 只有確認放開後才執行切換

### 防彈跳延遲時間選擇

- `DEBOUNCE_DELAY = 50` 毫秒是常見的防彈跳延遲時間
- 對於品質較好的按鈕，20-30ms 可能足夠
- 對於品質較差的按鈕，可能需要 100ms 或更長
- 可根據實際測試結果調整此值

## 狀態轉換圖

```
初始狀態：紅燈亮、黃燈滅 (led_state = True)
    |
    | [按下按鈕]
    ↓
[檢測按下邊緣] → [防彈跳檢查] → [等待放開]
    |
    | [放開按鈕]
    ↓
[防彈跳檢查] → [切換狀態]
    |
    ↓
狀態：紅燈滅、黃燈亮 (led_state = False)
    |
    | [再次按下並放開]
    ↓
狀態：紅燈亮、黃燈滅 (led_state = True)
    |
    ↓
[循環]
```

## 程式執行流程圖

```
開始
  ↓
初始化硬體與狀態
  ↓
進入主迴圈
  ↓
讀取按鈕當前狀態
  ↓
是否檢測到按下邊緣？
  ├─ 否 → 更新狀態記錄 → 繼續迴圈
  └─ 是 → 等待 50ms 防彈跳
      ↓
      確認按鈕確實被按下？
      ├─ 否 → 更新狀態記錄 → 繼續迴圈
      └─ 是 → 等待按鈕放開
          ↓
          等待 50ms 防彈跳
          ↓
          確認按鈕確實已放開？
          ├─ 否 → 更新狀態記錄 → 繼續迴圈
          └─ 是 → 切換 LED 狀態
              ↓
              更新狀態記錄
              ↓
              繼續迴圈
```

## 關鍵設計要點

1. **邊緣檢測**：只處理狀態變化瞬間，避免持續按下時重複觸發
2. **雙重防彈跳**：在按下和放開時都進行防彈跳檢查
3. **狀態確認**：每次防彈跳延遲後都重新確認狀態
4. **CPU 友善**：使用適當的延遲避免過度占用 CPU
5. **完整動作**：只有在「按下→放開」的完整動作後才切換狀態

## 測試建議

1. **正常操作測試**：快速按下並放開，確認 LED 正常切換
2. **長時間按下測試**：按住按鈕數秒後放開，確認只切換一次
3. **快速連續按下測試**：快速連續按下多次，確認每次都能正確響應
4. **防彈跳測試**：如果發現誤觸發，可增加 `DEBOUNCE_DELAY` 的值

## 可能的改進方向

1. **使用中斷（Interrupt）**：改用按鈕中斷來提高效率
2. **非阻塞式設計**：使用時間戳記而非 `sleep()`，讓程式可以同時處理其他任務
3. **可配置的防彈跳時間**：根據不同按鈕特性動態調整
4. **多按鈕支援**：擴展程式以支援多個按鈕控制不同的 LED

